if (__helpers_columnar_included)
	return ()
endif ()
set ( __helpers_columnar_included YES )

include ( printers )
macro ( return_if_target_found TRG LEGEND )
	if (TARGET ${TRG})
		diagst ( ${TRG} "${LEGEND}" )
		return ()
	endif ()
endmacro ()

# this macro is need for cross-compiling. If we just add path to CMAKE_PREFIX_PATH, it will NOT work with active root path,
# if search strategy set to 'only'. So, we add path to the root path in this case instead.
macro ( APPEND_PREFIX PATH )
	if (CMAKE_FIND_ROOT_PATH_MODE_PACKAGE STREQUAL ONLY)
		diags ( "CMAKE_FIND_ROOT_PATH before inclusion of update_bundle was ${CMAKE_FIND_ROOT_PATH}" )
		list ( APPEND CMAKE_FIND_ROOT_PATH "${PATH}" )
		diags ( "CMAKE_FIND_ROOT_PATH refreshed from update_bundle and is ${CMAKE_FIND_ROOT_PATH}" )
		#	endif ()
	else ()
		diags ( "CMAKE_PREFIX_PATH before inclusion of update_bundle was ${CMAKE_PREFIX_PATH}" )
		list ( APPEND CMAKE_PREFIX_PATH "${PATH}" )
		diags ( "CMAKE_PREFIX_PATH refreshed from update_bundle and is ${CMAKE_PREFIX_PATH}" )
	endif ()
endmacro ()

# helpers vars to shorten generate lines
set ( CLANGCXX "$<COMPILE_LANG_AND_ID:CXX,Clang,AppleClang>" )
set ( GNUCXX "$<COMPILE_LANG_AND_ID:CXX,GNU>" )
set ( GNUCLANGCXX "$<COMPILE_LANG_AND_ID:CXX,Clang,AppleClang,GNU>" )
set ( CLANGC "$<COMPILE_LANG_AND_ID:C,Clang,AppleClang>" )
set ( GNUC "$<COMPILE_LANG_AND_ID:C,GNU>" )
set ( GNUCLANGC "$<COMPILE_LANG_AND_ID:C,Clang,AppleClang,GNU>" )
set ( GNUC_CXX "$<OR:${GNUCXX},${GNUC}>" )
set ( CLANGC_CXX "$<OR:${CLANGCXX},${CLANGC}>" )
set ( GNUCLANGC_CXX "$<OR:${GNUCLANGCXX},${GNUCLANGC}>" )
if (CMAKE_CXX_COMPILER_ID STREQUAL "Clang" AND CMAKE_CXX_COMPILER_FRONTEND_VARIANT STREQUAL "MSVC")
	set ( CLANG_CL 1 )
	set ( ONLYGNUCLANGCXX 0 )
	set ( ONLYGNUCLANGC_CXX 0 )
	set ( MSCXX 1 )
else ()
	set ( CLANG_CL 0 )
	set ( ONLYGNUCLANGCXX "${GNUCLANGCXX}" )
	set ( ONLYGNUCLANGC_CXX "${GNUCLANGC_CXX}" )
	set ( MSCXX "$<COMPILE_LANG_AND_ID:CXX,MSVC>" )
endif ()
